
name: Mock Deployment

permissions:
  contents: write
  deployments: write

on:
  push:
    branches:
      - main
      - release/*
    tags:
      - '[0-9]+.[0-9]+.[0-9]+'   # semver tags like 1.2.3
  workflow_dispatch:
    inputs:
      ref:
        description: 'Branch or tag to deploy (e.g., main or 1.2.3)'
        required: false
        default: ''
      environment:
        description: 'Target environment'
        required: true
        type: choice
        options: [dev, staging, production]

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment || 'staging' }}

    steps:
      - name: Determine ref
        id: ref
        shell: bash
        run: |
          if [ -n "${{ github.event.inputs.ref }}" ]; then
            echo "REF=${{ github.event.inputs.ref }}" >> $GITHUB_ENV
          else
            echo "REF=${{ github.ref_name }}" >> $GITHUB_ENV
          fi

          # Tag detection: 1.2.3
          if [[ "${REF}" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "TAG_NAME=${REF}" >> $GITHUB_ENV
          else
            echo "TAG_NAME=" >> $GITHUB_ENV
          fi

      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ env.REF }}
          fetch-depth: 0  # needed to compute commit ranges and previous tags

      - name: Resolve repository name
        shell: bash
        run: |
          # Prefer github.event.repository.name; fall back to parsing GITHUB_REPOSITORY
          if [ -n "${{ github.event.repository.name }}" ]; then
            echo "REPO_NAME=${{ github.event.repository.name }}" >> $GITHUB_ENV
          else
            echo "REPO_NAME=${GITHUB_REPOSITORY#*/}" >> $GITHUB_ENV
          fi
          echo "RELEASE_NAME=next_${REPO_NAME}" >> $GITHUB_ENV

      - name: Mock deploy
        shell: bash
        run: |
          echo "Simulating deployment for ${REF} in environment ${{ inputs.environment || 'staging' }}"
          sleep 2

      # ---------- AUTO-EXTRACT JIRA ISSUE KEYS (SMP-####) ----------
      - name: Collect Jira issue keys from commit range
        id: collect-keys
        shell: bash
        run: |
          set -euo pipefail

          uniq_join() { awk '!seen[$0]++' | paste -sd, -; }

          RANGE=""
          KEYS=""

          # Case A: Tag deployment (1.2.3) -> diff against previous semver tag
          if [ -n "${TAG_NAME}" ]; then
            PREV_TAG=$(git tag --list --sort=-v:refname | grep -E '^[0-9]+\.[0-9]+\.[0-9]+$' | awk -v cur="${TAG_NAME}" 'f{print; exit} $0==cur{f=1}')
            if [ -n "${PREV_TAG}" ]; then
              RANGE="${PREV_TAG}..${TAG_NAME}"
            else
              RANGE="$(git rev-list --max-count=100 ${TAG_NAME})"
            fi

          # Case B: push to branch -> use GitHub's before..after
          elif [ "${{ github.event_name }}" = "push" ] && [ -n "${{ github.event.before }}" ]; then
            RANGE="${{ github.event.before }}..${{ github.sha }}"

          else
            # Manual / unknown -> last 100 commits on the checked-out ref
            RANGE="$(git rev-list --max-count=100 HEAD)"
          fi

          echo "Commit range for extraction: ${RANGE:-<list>}"

          if [[ "${RANGE}" == *".."* ]]; then
            KEYS=$(git log --pretty=%B ${RANGE} | grep -oE 'SMP-[0-9]+' | uniq_join || true)
          else
            KEYS=$(echo "${RANGE}" | xargs -I{} git log --pretty=%B -n 1 {} | grep -oE 'SMP-[0-9]+' | uniq_join || true)
          fi

          echo "Discovered Jira keys: ${KEYS}"
          echo "JIRA_TICKETS=${KEYS}" >> $GITHUB_ENV

      # ---------- FILTER OUT ISSUES ALREADY DEPLOYED TO PRODUCTION ----------
      - name: Exclude issues already deployed to production
        if: ${{ env.JIRA_TICKETS != '' }}
        shell: bash
        env:
          JIRA_BASE_URL: https://${{ secrets.JIRA_SUBDOMAIN }}.atlassian.net
          JIRA_EMAIL: ${{ secrets.JIRA_EMAIL }}
          JIRA_TOKEN: ${{ secrets.JIRA_TOKEN }}
        run: |
          set -euo pipefail

          IFS=',' read -ra KEYS <<< "${JIRA_TICKETS}"
          FILTERED=()

          get_issue_id () {
            curl -s -u "${JIRA_EMAIL}:${JIRA_TOKEN}" \
              -H "Accept: application/json" \
              "${JIRA_BASE_URL}/rest/api/3/issue/$1?fields=id" \
              | jq -r '.id'
          }

          get_providers () {
            jq -r '
              .summary as $s
              | [$s["deployment"].byInstanceType, $s["deployment-environment"].byInstanceType]
              | map(. // {}) | add
              | keys[]? ' 2>/dev/null
          }

          has_prod_success () {
            local issueId="$1" provider="$2" dtype="$3"
            local url="${JIRA_BASE_URL}/rest/dev-status/latest/issue/detail?issueId=${issueId}&applicationType=${provider}&dataType=${dtype}"
            local detail
            detail="$(curl -s -u "${JIRA_EMAIL}:${JIRA_TOKEN}" -H "Accept: application/json" "$url")" || return 1

            echo "$detail" | jq -e '
              (.detail // .details // []) as $blocks
              | if ($blocks | length) == 0 then false else
                  ( $blocks
                    | map(
                        ( .deployments // [] )
                        + ( ( .environments // [] ) | map( .deployments // [] ) | add )
                      )
                    | add
                  ) as $deps
                  | if ($deps | length) == 0 then false else
                      $deps
                      | map({
                          envName: ( .environment.name // .environmentName // (._env_container?.name // "") ),
                          envType: ( .environment.type // .environmentType // (._env_container?.type // "") ),
                          state:   ( .state // .status // .deploymentState // "" )
                        })
                      | map(
                          ( ( ( .envName | ascii_downcase ) | contains("prod") ) or
                            ( ( .envType | ascii_downcase ) | contains("prod") ) or
                            ( ( .envName // "" | ascii_downcase ) == "production" ) or
                            ( ( .envType // "" | ascii_downcase ) == "production" )
                          )
                          and ( ( .state | ascii_downcase ) | contains("success") )
                        )
                      | any
                    end
                end
            ' >/dev/null
          }

          for KEY in "${KEYS[@]}"; do
            ISSUE_KEY="$(echo "$KEY" | xargs)"
            ISSUE_ID="$( get_issue_id "$ISSUE_KEY" )" || ISSUE_ID=""

            if [ -z "$ISSUE_ID" ] || [ "$ISSUE_ID" = "null" ]; then
              echo "WARN: Could not resolve issue id for ${ISSUE_KEY}; keeping it."
              FILTERED+=("$ISSUE_KEY")
              continue
            fi

            SUMMARY_JSON="$(curl -s -u "${JIRA_EMAIL}:${JIRA_TOKEN}" \
                              -H "Accept: application/json" \
                              "${JIRA_BASE_URL}/rest/dev-status/latest/issue/summary?issueId=${ISSUE_ID}")"

            PROVIDERS=$(echo "$SUMMARY_JSON" | get_providers || true)

            PROD_SUCCESS="false"
            if [ -n "$PROVIDERS" ]; then
              while IFS= read -r P; do
                for DT in deployment deployment-environment; do
                  if has_prod_success "$ISSUE_ID" "$P" "$DT"; then
                    PROD_SUCCESS="true"
                    break
                  fi
                done
                [ "$PROD_SUCCESS" = "true" ] && break
              done <<< "$PROVIDERS"
            fi

            if [ "$PROD_SUCCESS" = "true" ]; then
              echo "Skipping ${ISSUE_KEY} (already deployed to production)"
            else
              FILTERED+=("$ISSUE_KEY")
            fi
          done

          if [ "${#FILTERED[@]}" -gt 0 ]; then
            (IFS=','; echo "JIRA_TICKETS_FILTERED=${FILTERED[*]}" >> $GITHUB_ENV)
            echo "Kept ${#FILTERED[@]} issues for staging processing."
          else
            echo "JIRA_TICKETS_FILTERED=" >> $GITHUB_ENV
            echo "No issues left after filtering."
          fi

      # ---------- CREATE/UPDATE JIRA RELEASE: ALWAYS 'next_<repo>' ON STAGING ----------
      - name: Add issues to Jira release 'next_<repo>'
        if: ${{ (inputs.environment || 'staging') == 'staging' && env.JIRA_TICKETS_FILTERED != '' }}
        uses: justin-jhg/jira-release-actions@v2
        with:
          jira_base_url: https://${{ secrets.JIRA_SUBDOMAIN }}.atlassian.net
          jira_user_email: ${{ secrets.JIRA_EMAIL }}
          jira_api_token: ${{ secrets.JIRA_TOKEN }}
          jira_project: SMP
          release_name: ${{ env.RELEASE_NAME }}    # next_<repo>
          tickets: ${{ env.JIRA_TICKETS_FILTERED }}
          create: true
          release: false
          archive: false
          time_zone: UTC                           # avoid invalid timezone errors

      # ---------- COMMENT *TAG* ON EACH (FILTERED) JIRA ISSUE ----------
      - name: Comment tag on Jira issues
        if: ${{ env.JIRA_TICKETS_FILTERED != '' && env.TAG_NAME != '' }}
        shell: bash
        env:
          JIRA_BASE_URL: https://${{ secrets.JIRA_SUBDOMAIN }}.atlassian.net
          JIRA_EMAIL: ${{ secrets.JIRA_EMAIL }}
          JIRA_TOKEN: ${{ secrets.JIRA_TOKEN }}
        run: |
          set -euo pipefail

          IFS=',' read -ra KEYS <<< "${JIRA_TICKETS_FILTERED}"
          echo "Commenting tag '${TAG_NAME}' on ${#KEYS[@]} issues..."

          for KEY in "${KEYS[@]}"; do
            ISSUE="$(echo "$KEY" | xargs)"
            ADF=$(jq -n --arg t "Tag: ${TAG_NAME}" '{
              body: {
                type: "doc",
                version: 1,
                content: [
                  { type: "paragraph", content: [ { type: "text", text: $t } ] }
                ]
              }
            }')

            http_code=$(curl -s -o /dev/null -w "%{http_code}" \
              -X POST \
              -H "Content-Type: application/json" \
              -u "${JIRA_EMAIL}:${JIRA_TOKEN}" \
              --data "${ADF}" \
              "${JIRA_BASE_URL}/rest/api/3/issue/${ISSUE}/comment")

            if [ "$http_code" != "201" ]; then
              echo "WARN: Failed to add comment to ${ISSUE} (HTTP ${http_code})"
            else
              echo "Commented on ${ISSUE}"
            fi
          done

      # ---------- Attach Tag Metadata to Deployment ----------
      - name: Attach Tag Metadata to Deployment
        if: always()
        shell: bash
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          DEPLOYMENT_URL="${{ github.api_url }}/repos/${{ github.repository }}/deployments"
          DEPLOYMENT_ID=$(gh api "$DEPLOYMENT_URL" --jq '.[0].id')

          echo "Deployment ID: $DEPLOYMENT_ID"
          echo "Tag: $TAG_NAME"

          DESC="Deployed ref: ${REF}"
          if [ -n "$TAG_NAME" ]; then
            DESC="${DESC} (tag: ${TAG_NAME})"
          fi

          gh api "$DEPLOYMENT_URL/$DEPLOYMENT_ID/statuses" \
            -f state=success \
            -f description="$DESC" \
            -f environment="${{ inputs.environment || 'staging' }}" \
            -f log_url="https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}" \
            -f auto_inactive=true
